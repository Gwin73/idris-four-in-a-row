module Main
import Data.Vect as V
import Prelude.List as L
import Data.String

%default total

data Player = X | O

other : Player -> Player
other X = O
other O = X

Show Player where
	show X = "X"
	show O = "O"

Eq Player where
	X == X = True
	O == O = True
	_ == _ = False	

Matrix : Nat -> Nat -> Type -> Type
Matrix n m a = Vect n $ Vect m a

record Board where 
	constructor MkBoard
	columns : Matrix 7 7 $ Maybe Player

rows : Board -> Matrix 7 7 $ Maybe Player
rows = transpose . columns

Show Board where
    show = unlines . map (concat . map (maybe "." show)) . toList . rows

diagonals1 : Board -> Vect 7 (n : Nat ** Vect n $ Maybe Player)
diagonals1 board = map V.catMaybes 
                 $ transpose 
                 $ ?d --type not possible since transpose requires square matrix

diagonals2 : Board -> Vect 7 (n : Nat ** Vect n $ Maybe Player)
diagonals2 = diagonals1 . MkBoard . transpose . columns

winner : Board -> Maybe Player --no group function
winner board = vectToMaybe 
			 $ snd $ V.mapMaybe V.head 
             $ snd $ filter (\x => length x >= 4)
             ?w

draw : Board -> Bool
draw board = all (all isJust) (rows board)

finLTE : {n : Nat} -> {f : Fin (S n)} -> LTE (finToNat f) n
finLTE {n = n} {f = FZ} = LTEZero
finLTE {n = Z} {f = (FS x)} = ?f_1
finLTE {n = (S k)} {f = (FS x)} = LTESucc $ finLTE {n = k} {f = x}
--finLTE {n = (S k)} {f = FZ} = ?f1 --
--finLTE {n = (S k)} {f = (FS x)} = ?f2

	--

legalMove : (n : Nat) -> Board -> Maybe $ GTE 6 n
legalMove n board with (natToFin n 7)
	| Nothing = Nothing
	| Just f with (isNothing $ V.index f $ V.head $ rows board)
		| False = Nothing
		| True = ?lm --Just $ finLTE {f}		
	
splitAt' : (n : Nat) -> Vect (1 + n + m) elem -> (Vect n elem, elem, Vect m elem)
splitAt' Z (x :: xs) = ([], x, xs)
splitAt' (S k) (x :: xs) with (splitAt' k xs) 
	| (l, m, r) = (x :: l, m, r)

plusMinusNeutral : {n : Nat} -> {m : Nat} -> (p : GTE m n) -> (n + (minus m n)) = m
plusMinusNeutral {n = Z} {m = m} _ = minusZeroRight m
plusMinusNeutral {n = (S _)} {m = Z} LTEZero impossible
plusMinusNeutral {n = (S _)} {m = Z} (LTESucc _) impossible
plusMinusNeutral {n = (S k1)} {m = (S k2)} p = 
	eqSucc (k1 + (minus k2 k1)) k2 (plusMinusNeutral $ fromLteSucc p)

succMinus : {n : Nat} -> {m : Nat} -> (p : GTE n m) -> (1 + minus n m) = (minus (1 + n) m) 
succMinus {n = Z} {m = Z} _ = Refl
succMinus {n = Z} {m = (S _)} LTEZero impossible
succMinus {n = Z} {m = (S _)} (LTESucc _) impossible
succMinus {n = (S k)} {m = Z} p = Refl
succMinus {n = (S k1)} {m = S (k2)} p = succMinus {n = k1} {m = k2} (fromLteSucc p)

catMaybesLTE : {n : Nat} -> {xs : Vect n (Maybe elem)} -> LTE (fst $ catMaybes xs) n
catMaybesLTE {n} {xs} = ?cm

move : Player -> Nat -> Board -> Maybe Board
move player n board with (legalMove n board)
    | Nothing = Nothing
    | Just p = Just board' where 
    	tmp : (Vect n $ Vect 7 $ Maybe Player, Vect 7 $ Maybe Player, Vect (minus 6 n) $ Vect 7 $ Maybe Player)
    	tmp = splitAt' n $ rewrite plusMinusNeutral p in columns board
    	left : Vect n $ Vect 7 $ Maybe Player
    	left = fst tmp
    	column : Vect 7 $ Maybe Player
    	column = fst $ snd tmp
    	right : Vect (minus 6 n) $ Vect 7 $ Maybe Player
    	right = snd $ snd tmp
    	temp : (n : Nat ** Vect n $ Maybe Player)
    	temp = let (n ** xs) = (catMaybes $ (Just player) :: (tail column)) in (n ** map Just xs)
    	-- column' : Vect 7 $ Maybe Player
    	-- column' = let (n ** xs) = temp in (replicate (minus 7 n) Nothing) ++ xs
    	board' = MkBoard 
    	       $ replace {P = \n => Matrix n 7 $ Maybe Player} (plusMinusNeutral $ lteSuccRight p) 
    	       $ rewrite sym $ succMinus p in left ++ [column] ++ right

record Game where
	constructor MkGame
	player : Player
	board : Board

partial gameloop : Game -> IO ()
gameloop game@(MkGame player board) = do
    putStr $ show player ++ "s turn: "
    line <- getLine
    case (parsePositive line) >>= (\n => move player n board) of
        Nothing => (print board) >>= (\_ => gameloop game)
        Just board' => do
            print board'
            if draw board
                then putStrLn "Draw!"
                else case winner board' of
                    Just player => putStrLn $ show player ++ " Won!"
                    Nothing => gameloop $ MkGame (other player) board'
partial main : IO ()
main = do
    let board = MkBoard (replicate 7 $ replicate 7 Nothing)
    print board
    gameloop $ MkGame X board